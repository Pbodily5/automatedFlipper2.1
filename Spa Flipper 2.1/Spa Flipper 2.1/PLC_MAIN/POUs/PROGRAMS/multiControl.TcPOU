<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="multiControl" Id="{7ac8876c-7553-4aa3-8d03-b92ac1cc6e8f}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM multiControl
VAR
	multiCtrlFrameIndex : INT; //Index used to switch frame on multiControlScreen
	
	aActionList 		: ARRAY[1..11] OF STRING := ['BRAKE OFF','BRAKE ON','DISABLE','ENABLE','HOME TO SENSOR','HOME TO TORQUE','MOVE TO POSITION','JOG','MOVE TO TORQUE','RESET','SET COUNT']; //List of usable actions found in FB_MultiMotorController.
	nActionIndex 		: INT;
	nPrevActionIndex 	: INT;
	pMotorRef1 			: POINTER TO FB_teknicMotorEC;
	pMotorRef2 			: POINTER TO FB_teknicMotorEC;
	pMotorRef3 			: POINTER TO FB_teknicMotorEC;
	pMotorRef4 			: POINTER TO FB_teknicMotorEC;
	aMotorEnabledRef 	: ARRAY[1..4] OF POINTER TO FB_teknicMotorEC; //Used to act on only motors currently enabled
	aMotorRef 			: ARRAY[1..4] OF POINTER TO FB_teknicMotorEC; // Used to update live values of motors in selection
	fRelease			: F_TRIG; 
	bReleaseTrig		: BOOL;

	// Motor Disp //
	nMotorControlIndex 		: INT; // Index used to change disp of motor controls. 0-Rotation, 1- Clamping, 2-Columns, 3-Width. 
	nPrevMotorControlIndex 	: INT; // INdex used to reset selections when frame changes 
	aDispFontColor 			: ARRAY[1..4] OF DWORD; // Used to change font color of motor display when toggled. 
	bHideDispMotor3 		: BOOL; //Used to hide or show controls for motor 3. 
	bHideDispMotor4			: BOOL;
	bHideDirection			: BOOL; //Hides direction of buttons based on selected action
	bHideSetPos				: BOOL; //Hides Set Position Entry based on selected action
	bHideSetTorq			: BOOL; //Hides Set Torque Entry based on selected action
	
	aMotorActive 	: ARRAY[1..4] OF BOOL; // Tracks user selected motors
	aMotorError 	: ARRAY[1..4] OF BOOL; // Indictates error for current action
	aMotorErrorId 	: ARRAY[1..4] OF UDINT; //Indicates error Id for current action
	aMotorDone 		: ARRAY[1..4] OF BOOL; //Indicates action is done
	aMotorInverted  : ARRAY[1..4] OF BOOL; //Indicates whether the motor is inverted
	
	sMotorDisp1 : STRING; // Used to dynamically change the title of motor 1. 
	sMotorDisp2 : STRING;
	sMotorDisp3 : STRING;
	sMotorDisp4 : STRING;
	
	// Motor Control //
	aMotorEnable 	: ARRAY[1..4] OF BOOL; //Array defining whether a motor is selected and should be used for the current action. 
	nCounter 		: INT; //Index for FOR loops.
	aMotorSpeed 	: ARRAY[1..4] OF LREAL; //Displays motors' speeds
	aMotorPos 		: ARRAY[1..4] OF LREAL; //Displays motors' positions
	aMotorTorque 	: ARRAY[1..4] OF LREAL; //Displays motors' torques
	aMotorSetPos 	: ARRAY[1..4] OF LREAL; //User set position for motors
	aMotorSetTorq 	: ARRAY[1..4] OF LREAL; //User set torque for motors
	bHomeDirection  : BOOL; // Direction of moves.
	nDirection 		: INT;	//Calculated direction based on inverted motor or not. 
	bExecute 		: BOOL; // Execute selected action 
	i : INT;
	
	// === parametersHandler Vars === //
	aStatusVar 				: ARRAY[1..12] OF BOOL; // Array containing boolean value for each status variable represented on screen. 
	aMotorSelection 		: ARRAY[1..10] OF STRING := ['LEFT ROTATION','RIGHT ROTATION','COLUMN 0','COLUMN 1','COLUMN 2','COLUMN 3','LEFT WIDTH','RIGHT WIDTH','LEFT CLAMPING','RIGHT CLAMPING']; //Drop down box to select motor to read/write
	nMotorSelectionIndex 	: INT; //Index of drop down box
	pMotorRefParam			: POINTER TO FB_teknicMotorEC;
	eParameter				: MC_AxisParameter;
	nParameterIndex			: INT; // Index of combo box for selected parameter
	fValueIn				: LREAL; // Value used to write to parameter
	fValueOut				: LREAL;// Value from read parameter. 
	bReadParam				: BOOL; // Btn used to trigger read parameter
	bWriteParam				: BOOL; // Btn used to trigger write parameter
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE nMotorControlIndex OF 
	0:// Rotation Selected
		aMotorRef[1] := ADR(GVL_devices.fbLftRotationMotor);
		aMotorRef[2] := ADR(GVL_devices.fbRhtRotationMotor);
		aMotorRef[3] := 0;
		aMotorRef[4] := 0;
		IF aMotorEnable[1] THEN
			pMotorRef1 := ADR(GVL_devices.fbLftRotationMotor);
		ELSE
			pMotorRef1 := 0;
		END_IF
		IF aMotorEnable[2] THEN
			pMotorRef2 := ADR(GVL_devices.fbRhtRotationMotor);
		ELSE
			pMotorRef2 := 0;
		END_IF
		pMotorRef3 := 0;
		pMotorRef4 := 0;
	    bHideDispMotor3 := TRUE;
	    bHideDispMotor4 := TRUE;
		sMotorDisp1 := 'LEFT ROTATION';
		sMotorDisp2 := 'RIGHT ROTATION';
		sMotorDisp3 := '';
		sMotorDisp4 := '';
		
	1:// Clamping Selected
		aMotorRef[1] := ADR(GVL_devices.fbLftClampMotor);
		aMotorRef[2] := ADR(GVL_devices.fbRhtClampMotor);
		aMotorRef[3] := 0;
		aMotorRef[4] := 0;
		IF aMotorEnable[1] THEN
			pMotorRef1 := ADR(GVL_devices.fbLftClampMotor);
		ELSE
			pMotorRef1 := 0;
		END_IF
		IF aMotorEnable[2] THEN
			pMotorRef2 := ADR(GVL_devices.fbRhtClampMotor);
		ELSE
			pMotorRef2 := 0;
		END_IF
		pMotorRef3 := 0;
		pMotorRef4 := 0;
	    bHideDispMotor3 := TRUE;
	    bHideDispMotor4 := TRUE;
		sMotorDisp1 := 'LEFT CLAMPING';
		sMotorDisp2 := 'RIGHT CLAMPING';
		sMotorDisp3 := '';
		sMotorDisp4 := '';
		
	2:// Columns Selected
		aMotorRef[1] := ADR(GVL_devices.fbColumn0Motor);
		aMotorRef[2] := ADR(GVL_devices.fbColumn1Motor);
		aMotorRef[3] := ADR(GVL_devices.fbColumn2Motor);
		aMotorRef[4] := ADR(GVL_devices.fbColumn3Motor);
		
		IF aMotorEnable[1] THEN
			pMotorRef1 := ADR(GVL_devices.fbColumn0Motor);
		ELSE
			pMotorRef1 := 0;
		END_IF
		IF aMotorEnable[2] THEN
			pMotorRef2 := ADR(GVL_devices.fbColumn1Motor);
		ELSE
			pMotorRef2 := 0;
		END_IF
		IF aMotorEnable[3] THEN
			pMotorRef3 := ADR(GVL_devices.fbColumn2Motor);
		ELSE
			pMotorRef3 := 0;
		END_IF
		IF aMotorEnable[4] THEN
			pMotorRef4 := ADR(GVL_devices.fbColumn3Motor);
		ELSE
			pMotorRef4 := 0;
		END_IF
	    bHideDispMotor3 := FALSE;
	    bHideDispMotor4 := FALSE;
		sMotorDisp1 := 'COLUMN 0';
		sMotorDisp2 := 'COLUMN 1';
		sMotorDisp3 := 'COLUMN 2';
		sMotorDisp4 := 'COLUMN 3';
		
	3:// Width Selected
		aMotorRef[1] := ADR(GVL_devices.fbLftWidthMotor);
		aMotorRef[2] := ADR(GVL_devices.fbRhtWidthMotor);
		aMotorRef[3] := 0;
		aMotorRef[4] := 0;
		IF aMotorEnable[1] THEN
			pMotorRef1 := ADR(GVL_devices.fbLftWidthMotor);
		ELSE
			pMotorRef1 := 0;
		END_IF
		IF aMotorEnable[2] THEN
			pMotorRef2 := ADR(GVL_devices.fbRhtWidthMotor);
		ELSE
			pMotorRef2 := 0;
		END_IF
		pMotorRef3 := 0;
		pMotorRef4 := 0;
	    bHideDispMotor3 := TRUE;
	    bHideDispMotor4 := TRUE;
		sMotorDisp1 := 'LEFT WIDTH';
		sMotorDisp2 := 'RIGHT WIDTH';
		sMotorDisp3 := '';
		sMotorDisp4 := '';
END_CASE

aMotorEnabledRef[1] := pMotorRef1;
aMotorEnabledRef[2] := pMotorRef2;
aMotorEnabledRef[3] := pMotorRef3;
aMotorEnabledRef[4] := pMotorRef4;

// === Update Motor Displays and Position,Torque,Inverted,and Speed. === //
FOR nCounter := 1 TO 4 BY 1 DO
	IF aMotorEnable[nCounter] THEN
		aDispFontColor[nCounter] := 16#FFFFFFFF;
	ELSE
		aDispFontColor[nCounter] := 16#FF000000;
	END_IF
END_FOR

FOR nCounter := 1 TO 4 BY 1 DO
	IF aMotorRef[nCounter] <> 0 THEN
		aMotorSpeed[nCounter] := aMotorRef[nCounter]^.fbMotor.NcToPlc.ActVelo;
	END_IF
END_FOR

FOR nCounter := 1 TO 4 BY 1 DO
	IF aMotorRef[nCounter] <> 0 THEN
		aMotorPos[nCounter] := aMotorRef[nCounter]^.fbMotor.NcToPlc.ActPos;
	END_IF
END_FOR

FOR nCounter := 1 TO 4 BY 1 DO
	IF aMotorRef[nCounter] <> 0 THEN
		aMotorTorque[nCounter] := aMotorRef[nCounter]^.fbMotor.NcToPlc.ActTorque;
	END_IF
END_FOR

FOR nCounter := 1 TO 4 BY 1 DO
	IF aMotorRef[nCounter] <> 0 THEN
		aMotorInverted[nCounter] := aMotorRef[nCounter]^.isMotorInverted;
	END_IF
END_FOR

// === Clear selections and user inputs when frame changes === //
IF nPrevMotorControlIndex <> nMotorControlIndex OR nActionIndex <> nPrevActionIndex THEN
	FOR nCounter := 1 TO 4 BY 1 DO
		aMotorEnable[nCounter] := FALSE;
		aMotorSetPos[nCounter] := 0;
		aMotorSetTorq[nCounter] := 0;
		aMotorActive[nCounter] := FALSE;
		aMotorError[nCounter] := FALSE;
		aMotorErrorId[nCounter] := 0;
		aMotorDone[nCounter] := FALSE;
	END_FOR
	nPrevMotorControlIndex := nMotorControlIndex;
	nPrevActionIndex := nActionIndex;
END_IF

// === Reset Motor State Variables and FB Variables at the end of an Execute === //
fRelease(CLK:=bExecute , Q=>bReleaseTrig );
IF bReleaseTrig THEN
	FOR nCounter := 1 TO 4 BY 1 DO
		aMotorActive[nCounter] := FALSE;
		aMotorError[nCounter] := FALSE;
		aMotorErrorId[nCounter] := 0;
		aMotorDone[nCounter] := FALSE;
		IF aMotorEnabledRef[nCounter] <> 0 THEN
			aMotorEnabledRef[nCounter]^.resetMotorCommands(); 	
		END_IF
	END_FOR
END_IF

// === Default Hide controls === //
bHideSetPos	 := TRUE;
bHideSetTorq := TRUE;
bHideDirection := TRUE;

// === CASE STATEMENT to execute actions on enabled motors === //
CASE nActionIndex OF 
	0:// Brake Off
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					IF aMotorEnabledRef[i]^.brakeOff() THEN
						aMotorDone[i] := TRUE;
					END_IF
				END_IF
			END_FOR
		END_IF
		
	1:// Brake On
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					IF aMotorEnabledRef[i]^.brakeOn() THEN
						aMotorDone[i] := TRUE;
					END_IF
				END_IF
			END_FOR
		END_IF
		
	2:// Disable
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					CASE aMotorEnabledRef[i]^.disable() OF
						1:// Done
							aMotorDone[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
			
	3:// Enable
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					CASE aMotorEnabledRef[i]^.enable() OF
						1:// Done
							aMotorDone[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	4:// homeToSensor
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					CASE aMotorEnabledRef[i]^.homeToSensor(0) OF
						1:// Done
							aMotorDone[i] := TRUE;
						2:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	5:// homeToTorque
		bHideSetTorq := FALSE;
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					aMotorEnabledRef[i]^.homeTorqueLimitIn := aMotorTorque[i];
					CASE aMotorEnabledRef[i]^.homeToTorque() OF
						1:// Done
							aMotorDone[i] := TRUE;
						2:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	6:// moveTo
		bHideSetPos	 := FALSE;
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					aMotorEnabledRef[i]^.homeTorqueLimitIn := aMotorTorque[i];
					CASE aMotorEnabledRef[i]^.moveTo('NULL',aMotorSetPos[i]/25.4) OF
						1:// Done
							aMotorDone[i] := TRUE;
						2,15:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	7:// moveToJog
	bHideDirection := FALSE;
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					IF bHomeDirection THEN
						IF aMotorEnabledRef[i]^.isMotorInverted THEN
							nDirection := 1;
						ELSE
							nDirection := 0;
						END_IF
					ELSE
						IF aMotorEnabledRef[i]^.isMotorInverted THEN
							nDirection := 0;
						ELSE
							nDirection := 1;
						END_IF
					END_IF
					CASE aMotorEnabledRef[i]^.moveToJog(nDirection) OF
						1:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	8:// moveToTorque
		bHideSetTorq	:= TRUE;
		bHideDirection 	:= FALSE;
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					IF bHomeDirection THEN
						IF aMotorEnabledRef[i]^.isMotorInverted THEN
							nDirection := 1;
						ELSE
							nDirection := 0;
						END_IF
					ELSE
						IF aMotorEnabledRef[i]^.isMotorInverted THEN
							nDirection := 0;
						ELSE
							nDirection := 1;
						END_IF
					END_IF
					CASE aMotorEnabledRef[i]^.moveToTorque('NULL',aMotorSetTorq[i],nDirection) OF
						1:// Done
							aMotorDone[i] := TRUE;
						2:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	9:// motorReset
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					CASE aMotorEnabledRef[i]^.reset() OF
						1:// Done
							aMotorDone[i] := TRUE;
						2:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
		
	10:// homeSetToCount
		bHideSetPos	 := FALSE;
		IF bExecute THEN
			FOR i := 1 TO 4 BY 1 DO
				IF aMotorEnabledRef[i] <> 0 THEN
					CASE aMotorEnabledRef[i]^.homeSetToCount(aMotorSetPos[i]) OF
						1:// Done
							aMotorDone[i] := TRUE;
						2:// Active
							aMotorActive[i] := TRUE;
						13:// Error
							aMotorError[i] := TRUE;	
							aMotorErrorId[i] := aMotorEnabledRef[i]^.motorErrorId;
					END_CASE
				END_IF
			END_FOR
		END_IF
END_CASE


IF multiCtrlFrameIndex = 3 THEN
	parametersHandler();
END_IF]]></ST>
    </Implementation>
    <Method Name="parametersHandler" Id="{e1c52b1c-3ce8-446f-bcbc-858102c18e12}">
      <Declaration><![CDATA[METHOD parametersHandler : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nMotorControlIndex OF 
	1://Left Rotation 
		pMotorRefParam := ADR(GVL_devices.fbLftRotationMotor);
	2://Right Rotation 
		pMotorRefParam := ADR(GVL_devices.fbRhtRotationMotor);
	3://Column 0
		pMotorRefParam := ADR(GVL_devices.fbColumn0Motor); 
	4://Column 1
		pMotorRefParam := ADR(GVL_devices.fbColumn1Motor);
	5://Column 2 
		pMotorRefParam := ADR(GVL_devices.fbColumn2Motor);
	6://Column 3
		pMotorRefParam := ADR(GVL_devices.fbColumn3Motor);
	7://Left Width
		pMotorRefParam := ADR(GVL_devices.fbLftWidthMotor);
	8://Right Width
		pMotorRefParam := ADR(GVL_devices.fbRhtWidthMotor);
	9://Left Clamp
		pMotorRefParam := ADR(GVL_devices.fbLftClampMotor);
	10://Right Clamp
		pMotorRefParam := ADR(GVL_devices.fbRhtClampMotor);
END_CASE

aStatusVar[1] := pMotorRefParam^.stMotorStatus.Error;
aStatusVar[2] := pMotorRefParam^.stMotorStatus.ErrorStop;
aStatusVar[3] := pMotorRefParam^.stMotorStatus.Disabled;
aStatusVar[4] := pMotorRefParam^.stMotorStatus.Operational;
aStatusVar[5] := pMotorRefParam^.stMotorStatus.ControlLoopClosed;
aStatusVar[6] := pMotorRefParam^.stMotorStatus.ProtectedMode;
aStatusVar[7] := pMotorRefParam^.stMotorStatus.Homed;
aStatusVar[8] := pMotorRefParam^.stMotorStatus.MotionCommandsLocked;
aStatusVar[9] := pMotorRefParam^.stMotorStatus.SoftLimitMinExceeded;
aStatusVar[10] := pMotorRefParam^.stMotorStatus.SoftLimitMaxExceeded;
aStatusVar[11] := pMotorRefParam^.stMotorStatus.DriveDeviceError;
aStatusVar[12] := pMotorRefParam^.stMotorStatus.Coupled;

eParameter := nParameterIndex;

IF bReadParam THEN
	fValueOut := pMotorRefParam^.fReadValue;
	CASE pMotorRefParam^.readRealParameter(eParameter) OF 
		1,13: bReadParam := FALSE;
			pMotorRefParam^.resetMotorCommands();
	END_CASE
END_IF

IF bWriteParam THEN
	CASE pMotorRefParam^.writeRealParameter(eParameter,fValueIn) OF 
		1,13: bWriteParam := FALSE;
			pMotorRefParam^.resetMotorCommands();
	END_CASE
END_IF

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>